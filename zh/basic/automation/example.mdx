---
title: "示例：用 JavaScript 创建自动化"
description: "通过调用 teable 接口创建自动化"
---

> 场景：电商订单从“已支付”更新为“已发货”后，自动向企业微信机器人群通知，便于客服与仓配实时同步。

### 前置准备

- **访问令牌**：个人访问令牌（PAT），建议以环境变量提供，例如 `process.env.TEABLE_TOKEN`
- **ID**：目标订单表的 `tableId`，以及所需字段的 `fieldId`（如 `fldStatus`、`fldOrderNo`、`fldCarrier`、`fldTrackingNo`）
- **Webhook**：企业微信机器人 Webhook URL（或 Microsoft Teams/钉钉等的 Hook）
- 参考：[`获取 ID`](../api-doc/get-id.mdx) 与 [`访问令牌`](../api-doc/token.mdx)

### 流程概览

1. 创建自动化
2. 创建触发器节点
3. 创建 HTTP 请求动作节点
4. 配置节点
5. 测试节点
6. 开启自动化

### JavaScript 示例
> 接口

```javascript
const baseUrl = "https://app.teable.ai/api"; // 根据实际环境调整：如 https://app.teable.cn/api
const token = process.env.TEABLE_TOKEN; // 推荐使用环境变量
const baseId = "bserxxxxxx"

const headers = {
  Authorization: `Bearer ${token}`,
  "Content-Type": "application/json",
};

async function http(method, url, body) {
  const res = await fetch(url, {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined,
  });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`${method} ${url} -> ${res.status} ${text}`);
  }
  return res.json();
}


// 创建自动化
async function createWorkflow(name, description) {
  // 占位端点：以你的环境为准
  return http("POST", `${baseUrl}/base/${baseId}/workflow`, {
    name,
    description,
  });
}

// 创建触发器节点（当记录创建时）
async function createTriggerNode(workflowId, config) {
  return http("POST", `${baseUrl}/base/${baseId}/workflow/${workflowId}/trigger`, {
    // recordCreated, recordUpdated, recordCreatedOrUpdated, buttonClick, formSubmitted, scheduledTime
    type: "recordCreated",
    config,
  });
}

// 测试触发器节点（若后面节点需要相关参数）
async function updateTriggerNode(workflowId, nodeId, config) {
  return http("POST", `${baseUrl}/base/${baseId}/workflow/${workflowId}/test/${nodeId}`, {
    type: "recordCreated",
    config,
  });
}

// 创建 HTTP 请求动作节点
async function createHttpNode(workflowId, parentNodeId, config) {
  return http("POST", `${baseUrl}/base/${baseId}/workflow/${workflowId}/action`, {
    type: "httpRequest",
    // 父节点，这里是 触发器节点: cmxxxx
    parentNodeId: parentNodeId,
  });
}

// 测试 HTTP 节点
async function testNode(workflowId, nodeId) {
  return http("POST", `${baseUrl}/base/${baseId}/workflow/${workflowId}/test/${nodeId}`);
}

// 开启/关闭自动化
async function toggleWorkflow(workflowId, enabled) {
  return http("PUT", `${baseUrl}/base/${baseId}/workflow/${workflowId}/active`, {
    // 传入 deactivate 可以关闭
    method: "activate",
  });
}
```

> 主函数

```javascript
async function main() {
  // ====== 按需替换以下变量 ======
  const tableId = "tblOrderxxxxxxxx"; // 订单表ID
  const fldTrackingNo = "fldTrackingNoxxxx"; // 运单号
  const wxWebhookUrl = "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=YOUR_KEY";

  // 1. 创建自动化
  const wf = await createWorkflow(
    "订单发货企业微信通知",
    "当订单状态为已发货时，向企业微信群发送通知"
  );

  const workflowId = wf.id;

  // 2. 创建触发器节点（监听记录更新）
  // 简化条件：当前状态==已发货（如需“从已支付到已发货”的前后态判断，请按实际接口支持配置 previous/current 条件）
  const triggerCfg = {
    tableId,
    filter: {
      // 示例表达式：仅当前为“已发货”时触发
      filterSet: [{
        fieldId: fldStatus,
        operator: "is",
        value: "已发货"
      }],
      conjunction: "and"
    },
  };

  const trigger = await createTriggerNode(workflowId, triggerCfg);

  // 3. 测试 trigger 生成变量可供后续节点使用
  const outputVariable = await testNode(workflowId, trigger.id);

  // 4. 创建 HTTP 请求动作节点（向企业微信机器人推送）
  // 使用变量占位：从触发器的记录上下文读取字段
  const httpCfg = {
    method: "post",
    url: {
      resolvable: true,
      type: "literal",
      value: "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=YOUR_KEY"
    },
    headers: [{
      key: {
        resolvable: true,
        type: "literal",
        value: "Content-Type"
      },
      value: {
        resolvable: true,
        type: "literal",
        value: "application/json"
      }
    }],
    bodyMode: "json",
    body: {
      type: "array",
      resolvable: true,
      nodes: [
        {
          resolvable: true,
          type: "literal",
          value: `{`
        },
        {
          resolvable: true,
          type: "literal",
          value: "\"msgtype\": \"markdown\","
        },
        {
          resolvable: true,
          type: "literal",
          value: "\"markdown\": {"
        },
        {
          resolvable: true,
          type: "literal",
          value: "\"content\":  \"订单号："
        },
        {
          // trigger 的nodeId,这个变量来自哪个node
          "fact: "cmh8xxx",
          // 变量的层级, 取自 test 的返回的变量值，参考test节点的返回值
          "keyStack": ["$.record", "$.record.fields"],
          params: [pipes: []],
          // 订单号变量占位符
          path: "$.record.fields.fldTrackingNoxxxx"
          resolvable: true,
          type: "fact"
        },
        {
          resolvable: true,
          type: "literal",
          value: "\""
        },
        {
          resolvable: true,
          type: "literal",
          value: "}"
        },
        {
          resolvable: true,
          type: "literal",
          value: "}"
        },
      ]
    },
  };

  const httpNode = await createHttpNode(workflowId, trigger.id, httpCfg);

  // 5. 测试 HTTP 节点（不会真正监听触发器，仅对配置做一次请求模拟/发送）
  // 注意：部分环境可能要求提供一个测试记录上下文，请按实际接口传入
  await testNode(workflowId, httpNode.id);

  // 6. 开启自动化
  await toggleWorkflow(workflowId, true);
}

main().catch((e) => {
  console.error("创建自动化失败", e);
});
```

### 安全与最佳实践
- 使用最小权限的 PAT，并限定可访问的空间/数据库。
- 敏感配置（Token、Webhook）存放在安全的密钥管理或环境变量中，避免硬编码。
- 在开启前先使用“测试节点”校验 HTTP 请求可达性与模板变量是否正确。
- 对外部接口设置合理的超时与重试，并监控失败告警。

### 相关文档

- [`自动化接口文档`](../../api-reference/automation/put-base-workflow-action)